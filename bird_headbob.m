function [t,state,phi_minus,phi_plus,phid_minus,phid_plus,Ekin_stance,Wgravity,Wneck,Wcoll,Wpush,Ekin_plus] = bird_headbob(x0, parms)%% Parameters, controls and initial stateg=parms.g;mp=parms.mp;   % [kg] pigeon pelvis massmh=parms.mh;  % [kg] pigeon head massalpha=parms.alpha; % [rad] leg spreadL=parms.L; % [m] leg lengthyh=parms.hh; % [m] head height relative to groundstep_length=parms.step_length; % [m] step lengthspeed=parms.speed; % [m/s] desired walking speed%step_time=parms.step_time; % [s] desired step durationI_o=mh*L^2; % [kg*m^2] moment of inertia of leg about basebobtime=parms.bobtime; % [s] time that the head is movingdelay=parms.delay;xh0=parms.xh0;% these are controls ('free parms')phid0=x0(1);Phat_push=x0(2);step_time=x0(3);% initial state:state0=[.5*pi-alpha; phid0; xh0; 0];%% perform push off and collision. % It is assumed that there is no interaction with the head during these% events; i.e. the massless and deformable neck does nothing ... phi_minus = state0(1); % leg angle [rad]phid_minus = state0(2); % [rad/s]% linear momentum of pelvis prior to push offmv_stance_end=mp*L*phid_minus*[-sin(phi_minus); cos(phi_minus)]; %[kg*m/s] % linear momentum of pelvis after push offmv_minus=mv_stance_end + Phat_push*[cos(phi_minus); sin(phi_minus)]; %[kg*m/s] % positive work done by push off; equals change in kinetic energy:Wpush=.5*(mv_minus'*mv_minus - mv_stance_end'*mv_stance_end)/mp; % [J]% update stance leg angle (and x coordinate of base??)phi_plus = .5*pi+alpha; % [rad]% find linear momentum of pelvis after collision by projecting onto new% movement direction of pelvis: -c1*e_n + c2*e_t = mv_mius; solve for c1/c2e_n=[cos(phi_plus); sin(phi_plus)]; % vector in direction of new stance lege_t=[-sin(phi_plus); cos(phi_plus)]; % vector in tangential direction of new stance legsol=[-e_n e_t]\mv_minus; mv_plus=sol(2)*e_t; % linear momentum of pelvis after push off and collisonPhat_coll=sol(1)*e_n; % [kg*m/s] collision impulse CHECK DIRECTION!!c_coll=sol(1); % coefficient of collision impulse, should be >0!! % update stance leg angular velocity; just pick x direction equation ... phid_plus=mv_plus(1)/(mp*L*-sin(phi_plus));% Energy dissipated by collision:Wcoll=.5*(mv_plus'*mv_plus - mv_minus'*mv_minus)/mp; % [J]% Kinetic energy after collision, per stance leg angular velocityEkin_plus=.5*I_o*phid_plus.^2;%% simulation of stance phase% update state0 to account for push off and collision having happened:state0(1:2)=[phi_plus; phid_plus];% ode45 will stop the integration when the event occursoptions = odeset('abstol',1e-8,'reltol',1e-8);%tspan=linspace(0,step_time,100);tspan=[0 step_time];% integrate using ode45 and the state-derivative function[t,state] = ode113(@fbird_stance, tspan, state0, options);% initialise stated and optional output[~,y0] = fbird_stance(0,state0);stated=zeros(size(state'));y = zeros(length(y0),length(t));for i=1:length(t)    [stated(:,1),y(:,i)] = fbird_stance(t(i),state(i,:)');endy=y';state_end=state(:,end);% check for energy conservation during stance phase[Ekin_stance,Wgravity,Wneck] = energy_bird(state,y);% end of bird_step; local functions follow%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function [stated,varargout] = fbird_stance(t,state)% state-derivative function for bird stance phase% the model consists of a point mass pelvis on a leg, in a rimlesswheel% setting. A point mass head is connected to the pelvis via a massless blob% (neck). In this function the head is fully constrained to zero acceleration.phi = state(1); % leg angle [rad]phid = state(2); % [rad/s]xh = state(3); % [m] x coordinate of pigeon head wrt base of stance legxhd = state(4); % [m/s]% coordinates of pelvis and head:rp=[L*cos(phi); L*sin(phi)]; % [m] coordinate of pelvesrh=[xh; yh]; % [m] coordinate of pelves% DO SOMETHING CLEVER WITH MOD DOWN HERE!!!% acceleration of head:if t>delay && t<delay+bobtime % now we are doing headbobbing ...     % parameterizing: a*cos(b*t+c)+d    a=-.5*step_length;    b=pi/bobtime;    c=-b*delay;    d=xh0+.5*step_length;    %xh = a*cos(b*t+c)+d; % [m] x position of head    %xhd = -a*b*sin(b*t+c);    xhdd = -a*b*b*cos(b*t+c); % [m/s^2]else    xhdd=0;end% force of neck on head (equals minus force of neck on pelvis!!): Fnh = mh*[xhdd; -g]; % [N]Fnp = -Fnh; % [N] force of neck on pelvis% moment of force of neck on pelvis about base of stance leg.M_Fnp=cross2d(rp,Fnp); % [Nm]% pure moment of neck on pelvis (to satisfy massless neck), equals% r_p_wrt_h x F_pn (F_pn=F_nh)M_np=cross2d(rp-rh,Fnh); % [Nm]% moment of gravitational force on pelvis about base of stance leg.Fgp=[0;mp*g]; % [N]M_Fgp=cross2d(rp,Fgp); % [Nm]% impulse momentum equation about base of stance leg:phidd=(M_np + M_Fnp + M_Fgp)/I_o; % [rad/s^2]% Head motion. In this case the derivative is zero such that the head is% stationary...stated = [phid; phidd; xhd; xhdd];if nargout>1    varargout{1}=[Fnh' Fnp' M_np Fgp'];endend % fbird_stance%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function [Ekin,Wgp,Wneck] = energy_bird(state,y)% returns the energy of the system at a given state% state can also be given as an arrayFnh=y(:,1:2); % [N] F neck on headFnp=y(:,3:4); % [N] F neck on pelvisMnp=y(:,5); % [N] Moment of F neck on pelvisFgp=y(:,6:7); % [N] F gravity on pelvisphi = state(:,1); % leg angle [rad]phid = state(:,2); % [rad/s]xh = state(:,3); % [m] x coordinate of pigeon head wrt base of stance legxhd = state(:,4); % [m/s]xp=L*cos(phi); % [m] x coordinate of pelvesyp = L*sin(phi); % [m] y coordiate of pelvis;% kinetic energy of leg + headEkin = 0.5*I_o*phid.^2 + .5*mh*xhd.^2; %[J]Ekin = Ekin-Ekin(1); % [J] change in kinetic energy% mechanical work done on leg + headWgp = cumtrapz(yp,Fgp(:,2)); % [J] work done by gravityWnp = cumtrapz(xp,Fnp(:,1)) + cumtrapz(yp,Fnp(:,2)) + cumtrapz(phi,Mnp);Wnh = cumtrapz(xh,Fnh(:,1)); % [J]Wneck=Wnp+Wnh;end % energyrwfunction [M] = cross2d(r,F)% computes cross product of two 2D vectorsM=r(1)*F(2)-r(2)*F(1);endend % outer function